# Algorithms_DS
Solutions to data structures and algorithm problems

## Day 1
> Given a string, find the length of the longest substring without repeating characters.

## Day 2
>1. There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty.
>2. Longest Common Subsequence using DP.
>3. Longest UnCommon Subsequence

### Day 3
>1. Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.

## Day 4
>1. Given a binary tree, find the leftmost value in the last row of the tree.
>2. Since the problem desciption is long, you can find it [here](https://leetcode.com/problems/validate-ip-address/)

## Day 5
>1. You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value.
The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.
>2. Find the sum of all the leaves in a given binary tree.
>3. Find the sum of all the left leaves in a given binary tree.
>4. Find the sum of all the right leaves in a given binary tree.
>5. Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
Note: A leaf is a node with no children.

## Day 6
>1. Given an array of ages of people, find the total number of friend requests possible to be send according to a given criteria.

## Day 7
>1. You have a list of words and a pattern, and you want to know which words in words matches the pattern.
A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.
(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)
Return a list of the words in words that match the given pattern. 
You may return the answer in any order.

## Day 8 
>1. Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

## Day 9
>1. Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

## Day 10
>1. You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.
Find out how many ways to assign symbols to make sum of integers equal to target S.

## Day 11
>1. Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:
Copy All: You can copy all the characters present on the notepad (partial copy is not allowed).
Paste: You can paste the characters which are copied last time.
Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.

## Day 12 
>1. Given an unsorted array of nonnegative integers, find a continous subarray which adds to a given number.

## Special edition
<details><summary>InterviewBit</summary>

>1. Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).
>2. Given a read only array of n + 1 integers between 1 and n, find one number that repeats in linear time using less than O(n) space and traversing the stream sequentially O(1) times.
>3. Given a list of non negative integers, arrange them such that they form the largest number.
>4. Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
>5. Given an unsorted integer array, find the first missing positive integer.
>6. Given a singly linked list of N nodes. The task is to find middle of the linked list. For example, if given linked list is 1->2->3->4->5 then output should be 3. 
If there are even nodes, then there would be two middle nodes, we need to print second middle element. For example, if given linked list is 1->2->3->4->5->6 then output should be 4.
>7. Given a linked list of N nodes. The task is to check if the the linked list has a loop. Linked list can contain self loop.
>8. Write a function that returns true if the given Binary Tree is SumTree else false. A SumTree is a Binary Tree where value of every node x is equal to sum of nodes present in its left subtree and right subtree of x. An empty tree is SumTree and sum of an empty tree can be considered as 0. A leaf node is also considered as SumTree.
>9. Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
>10. Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
>11. Given an array A of N positive integers and another number X. Determine whether or not there exist two elements in A whose sum is exactly X.
>12. Given an input string, reverse the string word by word.
</details>

## Day 13
>1. You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.
The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A".

## Day 14
>1. Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once. Your solution should run in O(log n) time and O(1) space.

## Day 15
>1. Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.

## Day 16
>1. Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.
